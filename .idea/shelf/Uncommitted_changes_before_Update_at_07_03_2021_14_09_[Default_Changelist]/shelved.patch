Index: stack.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/stack.py b/stack.py
new file mode 100644
--- /dev/null	(date 1615118971673)
+++ b/stack.py	(date 1615118971673)
@@ -0,0 +1,26 @@
+'''
+empty stack [0]
+[3,[2,[1,[0]]]] stack that contains 3,2,1
+3 is the top of the stack
+'''
+
+# creates a stack with x
+
+def create(x):
+    s=[0]
+    insert(s,x)
+    return s
+
+def is_empty(s):
+    return s==[0]
+
+def insert(s,x):
+    s[0]=[x,s[0]]
+
+def remove(s):
+    if is_empty(s): # underflow
+        return 0
+    x=s[0][0]
+    s[0]=s[0][1]
+    return x
+
Index: state.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/state.py b/state.py
new file mode 100644
--- /dev/null	(date 1615118924430)
+++ b/state.py	(date 1615118924430)
@@ -0,0 +1,56 @@
+'''
+The state is a list of 2 items: the board, the path
+The target for 8-puzzle is: (zero is the hole)
+012
+345
+678
+'''
+
+import random
+import math
+
+#returns a random board nXn
+def create(n):
+    s=list(range(n*n))      # s is the board itself. a vector that represent a matrix. s=[0,1,2....n^2-1]
+    m="<>v^"                # m is "<>v^" - for every possible move (left, right, down, up)
+    for i in range(n*n*n):  # makes n^3 random moves
+        if_legal(s,m[random.randrange(4)])
+    return [s,""]           # at the beginning "" is an empty path, later on path
+                            # contains the path that leads from the initial state to the state
+
+def get_next(x):            # returns a list of the children states of x
+    ns=[]                   # the next state list
+    for i in "<>v^":
+        s=x[0][:]           # [:] - copies the board in x[0]
+        if_legal(s,i)       # try to move in direction i
+        # checks if the move was legal and...
+        if s.index(0)!=x[0].index(0) and \
+           (x[1]=="" or x[1][-1]!="><^v"["<>v^".index(i)]): # check if it's the first move or it's a reverse move
+            ns.append([s,x[1]+i])   # appends the new state to ns
+    return ns
+
+
+def path_len(x):
+    return len(x[1])
+
+def is_target(x):
+    n=len(x[0])                     # the size of the board
+    return x[0]==list(range(n))     # list(range(n)) is the target state
+
+#############################
+def if_legal(x,m):                  # gets a board and a move and makes the move if it's legal
+    n=int(math.sqrt(len(x)))        # the size of the board is nXn
+    z=x.index(0)                    # z is the place of the empty tile (0)
+    if z%n>0 and m=="<":            # checks if the empty tile is not in the first col and the move is to the left
+        x[z]=x[z-1]                 # swap x[z] and x[z-1]...
+        x[z-1]=0                    # ...and move the empty tile to the left
+    elif z%n<n-1 and m==">":        # check if the empty tile is not in the n's col and the move is to the right
+        x[z]=x[z+1]
+        x[z+1]=0
+    elif z>=n and m=="^":           # check if the empty tile is not in the first row and the move is up
+        x[z]=x[z-n]
+        x[z-n]=0
+    elif z<n*n-n and m=="v":        # check if the empty tile is not in the n's row and the move is down
+        x[z]=x[z+n]
+        x[z+n]=0
+
Index: frontier.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/frontier.py b/frontier.py
new file mode 100644
--- /dev/null	(date 1615118733385)
+++ b/frontier.py	(date 1615118733385)
@@ -0,0 +1,34 @@
+import stack
+import state
+
+
+# [stack, max. depth, init. state, try next level?,
+# , total items pushed] The last one needs to be added
+def create(x):
+    s = stack.create(x)
+    return [s, 1, x, 0, False]
+
+
+def is_empty(s):
+    return stack.is_empty(s[0]) and not s[4]  # stack is empty and try next level is false
+
+
+def insert(s, x):
+    if state.path_len(x) <= s[1]:  # check if x is not too deep
+        stack.insert(s[0], x)  # insert x to stack
+    else:
+        s[4] = True  # there is a reason to search deeper if needed
+
+
+def remove(s):
+    if stack.is_empty(s[0]):  # check is there are no states in the stack
+        if s[4]:  # check if there is a reason to search deeper
+            s[1] += 1  # increase search depth
+            s[4] = False  # meanwhile there is no evidence to need to search deeper
+            # print(s[1])         # print what level we finished searching
+            return s[2]  # return the initial state
+        else:
+            return 0
+    return stack.remove(s[0])  # if there are items in the stack ...
+
+
Index: search.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/search.py b/search.py
new file mode 100644
--- /dev/null	(date 1615118785950)
+++ b/search.py	(date 1615118785950)
@@ -0,0 +1,21 @@
+search
+
+import state
+import frontier
+
+def search(n):
+    s=state.create(n)
+    print(s)
+    f=frontier.create(s)
+    while not frontier.is_empty(f):
+        s=frontier.remove(f)
+        if state.is_target(s):
+            return [s, f[1], f[3]]
+        ns=state.get_next(s)
+        #print(ns)
+        for i in ns:
+            frontier.insert(f,i)
+    return 0
+
+answer=search(3)
+print(answer)
\ No newline at end of file
